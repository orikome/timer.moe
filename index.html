<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TimerThing</title>

    <!-- Alpine.js and Tailwind CSS via CDN (no build step) -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />

    <!-- Custom CSS with color variables -->
    <link rel="stylesheet" href="styles.css" />

    <style>
      body {
        font-family: "Inter", sans-serif;
      }
    </style>
  </head>
  <body class="app-background min-h-screen p-6">
    <!-- Change from max-w-lg to max-w-4xl to accommodate the wider layout -->
    <div x-data="timerApp()" class="max-w-4xl mx-auto">
      <h1 class="text-3xl font-semibold text-center mb-8 text-slate-800">
        TimerThing
      </h1>

      <!-- Timer Cards - Convert to grid layout -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
        <template x-for="(timer, index) in timers" :key="timer.id">
          <div
            :class="`p-5 rounded-2xl shadow-lg transition-all relative overflow-hidden timer-card ${getColorClass(timer.color, 'bg')}`"
            x-transition:enter="timer-transition-enter-active"
            x-transition:enter-start="timer-transition-enter-from"
            x-transition:leave="timer-transition-leave-active"
            x-transition:leave-end="timer-transition-leave-to"
          >
            <!-- Progress Bar - only for countdown timers -->
            <template x-if="timer.mode === 'countdown' && timer.isRunning">
              <div
                class="absolute inset-0 transition-transform duration-500"
                :class="getColorClass(timer.color, 'progress')"
                :style="`transform: translateY(${ticker, getProgressPercentage(timer)}%)`"
              ></div>
            </template>

            <!-- Content wrapper with z-index -->
            <div class="relative z-10">
              <!-- Close Button (X in corner) - Enhanced -->
              <button
                @click="removeTimer(index)"
                class="absolute top-1 right-1 w-7 h-7 flex items-center justify-center rounded-full bg-white/30 hover:bg-white/60 text-slate-600 hover:text-slate-900 transition-all hover:scale-110 text-lg"
                aria-label="Remove timer"
              >
                Ã—
              </button>

              <!-- Timer Header - Centered with larger name -->
              <div class="flex flex-col items-center mb-3">
                <input
                  type="text"
                  x-model="timer.name"
                  @change="saveTimers()"
                  class="bg-transparent font-medium text-2xl text-center timer-name-input px-2 py-1 max-w-full"
                  :placeholder="`Timer ${index + 1}`"
                />

                <!-- Color Selector - Centered -->
                <div class="flex space-x-3 mt-3">
                  <template x-for="color in colors" :key="color">
                    <button
                      @click="timer.color = color; saveTimers()"
                      :class="`w-6 h-6 rounded-full hover:scale-125 transition-all color-selector-${color} ${timer.color === color ? 'ring-2 ring-slate-700 ring-offset-2' : ''}`"
                      :aria-label="`Select ${color} color`"
                    ></button>
                  </template>
                </div>
              </div>

              <!-- Timer Display - Enhanced -->
              <div class="text-center py-4">
                <div
                  class="text-5xl font-mono font-semibold timer-display"
                  :class="{'timer-running': timer.isRunning}"
                  x-text="formatTime(timer)"
                ></div>
              </div>

              <!-- Timer Controls - Improved layout -->
              <div
                class="flex flex-wrap items-center justify-between gap-3 mt-3"
              >
                <!-- Mode Toggle -->
                <button
                  @click="toggleMode(timer)"
                  class="timer-button px-3 py-2 rounded-xl text-sm"
                >
                  <span
                    x-text="timer.mode === 'countdown' ? 'Countdown' : 'Stopwatch'"
                  ></span>
                </button>

                <!-- Countdown Duration (only for countdown mode) -->
                <template x-if="timer.mode === 'countdown'">
                  <div class="flex items-center">
                    <input
                      type="number"
                      x-model.number="timer.duration"
                      @change="updateDuration(timer)"
                      class="w-14 duration-input rounded-xl px-2 py-1.5 text-center text-sm"
                      min="1"
                    />
                    <span class="ml-1 text-sm">min</span>
                  </div>
                </template>

                <!-- Main Controls -->
                <div class="flex space-x-2">
                  <button
                    @click="toggleTimer(timer)"
                    class="timer-button px-4 py-2 rounded-xl text-sm font-medium"
                  >
                    <span x-text="timer.isRunning ? 'Pause' : 'Start'"></span>
                  </button>

                  <button
                    @click="resetTimer(timer)"
                    class="timer-button px-4 py-2 rounded-xl text-sm font-medium"
                  >
                    Reset
                  </button>
                </div>
              </div>
            </div>
          </div>
        </template>
      </div>

      <!-- Add Timer Button - Enhanced -->
      <div class="text-center">
        <button
          @click="addTimer()"
          class="add-button px-6 py-3 rounded-xl font-medium text-lg transition-all"
        >
          Add Timer
        </button>
      </div>
    </div>

    <script>
      function timerApp() {
        return {
          timers: [],
          colors: ["pink", "blue", "green", "purple", "yellow"],
          ticker: 0,

          init() {
            this.loadTimers();
            this.startTimerUpdates();

            // Force UI updates every 500ms when timers are running
            setInterval(() => {
              if (this.timers.some((t) => t.isRunning)) {
                this.ticker++;
              }
            }, 500);

            // Handle page visibility changes
            document.addEventListener("visibilitychange", () => {
              if (document.visibilityState === "visible") {
                this.updateTimersOnResume();
              }
            });
          },

          loadTimers() {
            const savedTimers = localStorage.getItem("timers");

            if (savedTimers) {
              try {
                this.timers = JSON.parse(savedTimers);
                this.updateTimersOnResume();
              } catch (e) {
                console.error("Error loading timers:", e);
                this.timers = [];
              }
            }

            // Add a default timer if none exists
            if (!this.timers.length) {
              this.addTimer();
            }
          },

          updateTimersOnResume() {
            const now = Date.now();

            this.timers.forEach((timer) => {
              if (timer.isRunning && timer.lastUpdated) {
                // Calculate elapsed time while page was closed
                const timePassed = now - timer.lastUpdated;

                if (timer.mode === "countdown") {
                  // For countdown, check if timer should have completed
                  const durationMs = timer.duration * 60 * 1000;
                  timer.elapsed += timePassed;

                  if (timer.elapsed >= durationMs) {
                    timer.elapsed = durationMs;
                    timer.isRunning = false;
                    timer.lastUpdated = null;
                    // Play notification sound on resume if timer finished
                    this.playNotification();
                  } else {
                    timer.lastUpdated = now;
                  }
                } else {
                  // For stopwatch, just add the elapsed time
                  timer.elapsed += timePassed;
                  timer.lastUpdated = now;
                }
              }
            });

            this.saveTimers();
          },

          saveTimers() {
            localStorage.setItem("timers", JSON.stringify(this.timers));
          },

          addTimer() {
            const now = Date.now();
            const newTimer = {
              id: now.toString(),
              name: "",
              mode: "stopwatch", // Changed from 'countdown' to 'stopwatch'
              duration: 25,
              color:
                this.colors[Math.floor(Math.random() * this.colors.length)],
              isRunning: true, // Auto-start the timer
              elapsed: 0,
              lastUpdated: now, // Set the lastUpdated to now for auto-start
            };

            this.timers.push(newTimer);
            this.saveTimers();
          },

          removeTimer(index) {
            this.timers.splice(index, 1);
            this.saveTimers();
          },

          toggleMode(timer) {
            timer.mode = timer.mode === "countdown" ? "stopwatch" : "countdown";
            timer.isRunning = false;
            timer.elapsed = 0;
            timer.lastUpdated = null;
            this.saveTimers();
          },

          toggleTimer(timer) {
            const now = Date.now();

            if (timer.isRunning) {
              // Pause
              if (timer.lastUpdated) {
                timer.elapsed += now - timer.lastUpdated;
              }
              timer.isRunning = false;
              timer.lastUpdated = null;
            } else {
              // Start
              timer.isRunning = true;
              timer.lastUpdated = now;
            }

            this.saveTimers();
          },

          resetTimer(timer) {
            timer.isRunning = false;
            timer.elapsed = 0;
            timer.lastUpdated = null;
            this.saveTimers();
          },

          updateDuration(timer) {
            // Ensure duration is at least 1 minute
            if (timer.duration < 1) timer.duration = 1;
            timer.elapsed = 0;
            this.saveTimers();
          },

          startTimerUpdates() {
            // Update timers every second
            setInterval(() => {
              const now = Date.now();
              let needsSave = false;

              this.timers.forEach((timer) => {
                if (timer.isRunning) {
                  if (timer.mode === "countdown") {
                    const durationMs = timer.duration * 60 * 1000;
                    const totalElapsed =
                      timer.elapsed + (now - timer.lastUpdated);

                    if (totalElapsed >= durationMs) {
                      // Timer complete
                      timer.elapsed = durationMs;
                      timer.isRunning = false;
                      timer.lastUpdated = null;
                      this.playNotification();
                      needsSave = true;
                    }
                  }
                }
              });

              if (needsSave) {
                this.saveTimers();
              }
            }, 1000);
          },

          formatTime(timer) {
            // Access the ticker to ensure this function gets re-evaluated
            // when the ticker changes
            this.ticker;

            let timeMs;

            if (timer.isRunning) {
              const elapsed = timer.elapsed + (Date.now() - timer.lastUpdated);

              if (timer.mode === "countdown") {
                const durationMs = timer.duration * 60 * 1000;
                timeMs = Math.max(0, durationMs - elapsed);
              } else {
                timeMs = elapsed;
              }
            } else {
              if (timer.mode === "countdown") {
                const durationMs = timer.duration * 60 * 1000;
                timeMs = Math.max(0, durationMs - timer.elapsed);
              } else {
                timeMs = timer.elapsed;
              }
            }

            // Format the time as HH:MM:SS
            const totalSeconds = Math.floor(timeMs / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            return `${hours.toString().padStart(2, "0")}:${minutes
              .toString()
              .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
          },

          playNotification() {
            try {
              // Add a visual notification in addition to sound
              const notificationDuration = 3000;

              // Create notification element
              const notification = document.createElement("div");
              notification.className =
                "fixed bottom-4 right-4 bg-indigo-600 text-white py-2 px-4 rounded-lg shadow-lg z-50 animate-bounce";
              notification.innerHTML = "Timer completed!";

              // Add to document
              document.body.appendChild(notification);

              // Play sound if available
              try {
                const audio = new Audio("notification-sound.mp3");
                audio.play();
              } catch (e) {
                console.log("Could not play notification sound");
              }

              // Remove after duration
              setTimeout(() => {
                notification.classList.add("opacity-0");
                notification.style.transition = "opacity 0.5s ease";

                setTimeout(() => {
                  document.body.removeChild(notification);
                }, 500);
              }, notificationDuration);
            } catch (e) {
              console.error("Error showing notification:", e);
            }
          },

          getColorClass(color, type) {
            if (type === "bg") {
              return `timer-bg-${color}`;
            }
            if (type === "progress") {
              return `progress-bg-${color}`;
            }
            return "";
          },

          getProgressPercentage(timer) {
            if (timer.mode !== "countdown") return 0;

            const durationMs = timer.duration * 60 * 1000;
            let elapsed = timer.elapsed;

            if (timer.isRunning && timer.lastUpdated) {
              elapsed += Date.now() - timer.lastUpdated;
            }

            // Calculate how much is remaining (0-100)
            const remaining = Math.max(
              0,
              Math.min(100, (elapsed / durationMs) * 100)
            );

            // Return negative percentage so it comes from the top
            return -100 + remaining;
          },
        };
      }
    </script>
  </body>
</html>
