<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TimerThing</title>
  
  <!-- Alpine.js and Tailwind CSS via CDN (no build step) -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Google Fonts - Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-100 to-blue-200 min-h-screen p-6">
  <!-- Change from max-w-lg to max-w-4xl to accommodate the wider layout -->
  <div x-data="timerApp()" class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-semibold text-center mb-8 text-slate-800">TimerThing</h1>
    
    <!-- Timer Cards - Convert to grid layout -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
      <template x-for="(timer, index) in timers" :key="timer.id">
        <div :class="`p-6 rounded-2xl shadow-lg transition-all ${getColorClass(timer.color, 'bg')} relative`">
          <!-- Close Button (X in corner) - Repositioned -->
          <button 
            @click="removeTimer(index)"
            class="absolute top-3 right-3 w-7 h-7 flex items-center justify-center rounded-full bg-white/30 hover:bg-white/60 text-slate-600 hover:text-slate-900 transition-colors text-lg"
            aria-label="Remove timer">
            Ã—
          </button>
          
          <!-- Timer Header - Modified to be more responsive -->
          <div class="flex flex-wrap justify-between items-center mb-4 pt-4">
            <input 
              type="text" 
              x-model="timer.name" 
              @change="saveTimers()"
              class="bg-transparent font-medium text-xl focus:outline-none border-b border-transparent focus:border-slate-400 px-2 py-1 min-w-0 flex-grow mr-3"
              :placeholder="`Timer ${index + 1}`"
            />
            
            <!-- Color Selector - Added flex-shrink, reduced spacing -->
            <div class="flex space-x-2 flex-shrink-0">
              <template x-for="color in colors" :key="color">
                <button 
                  @click="timer.color = color; saveTimers()"
                  :class="`w-5 h-5 rounded-full hover:scale-110 transition-transform ${getColorClass(color, 'bg')} ${timer.color === color ? 'ring-2 ring-slate-700 ring-offset-1' : ''}`"
                  :aria-label="`Select ${color} color`">
                </button>
              </template>
            </div>
          </div>
          
          <!-- Timer Display -->
          <div class="text-center py-8">
            <div 
              class="text-5xl font-mono font-semibold"
              :class="{'animate-pulse': timer.isRunning}"
              x-text="formatTime(timer)">
            </div>
          </div>
          
          <!-- Timer Controls -->
          <div class="flex flex-wrap items-center justify-between gap-3">
            <!-- Mode Toggle -->
            <button 
              @click="toggleMode(timer)"
              :class="`px-4 py-2 rounded-xl text-base ${getColorClass(timer.color, 'button')}`">
              <span x-text="timer.mode === 'countdown' ? 'Countdown' : 'Stopwatch'"></span>
            </button>
            
            <!-- Countdown Duration (only for countdown mode) -->
            <template x-if="timer.mode === 'countdown'">
              <div class="flex items-center">
                <input 
                  type="number" 
                  x-model.number="timer.duration" 
                  @change="updateDuration(timer)"
                  class="w-16 bg-white/40 rounded-xl px-3 py-2 text-center focus:outline-none text-base"
                  min="1"
                />
                <span class="ml-2 text-base">min</span>
              </div>
            </template>
            
            <!-- Main Controls -->
            <div class="flex space-x-3">
              <button 
                @click="toggleTimer(timer)" 
                :class="`px-4 py-2 rounded-xl text-base font-medium ${getColorClass(timer.color, 'button')}`">
                <span x-text="timer.isRunning ? 'Pause' : 'Start'"></span>
              </button>
              
              <button 
                @click="resetTimer(timer)" 
                :class="`px-4 py-2 rounded-xl text-base font-medium ${getColorClass(timer.color, 'button')}`">
                Reset
              </button>
            </div>
          </div>
        </div>
      </template>
    </div>
    
    <!-- Add Timer Button -->
    <div class="text-center">
      <button 
        @click="addTimer()" 
        class="px-6 py-3 rounded-xl font-medium text-lg transition-colors bg-indigo-100 hover:bg-indigo-200 text-indigo-800">
        Add Timer
      </button>
    </div>
  </div>

  <script>
    function timerApp() {
      return {
        timers: [],
        colors: ['pink', 'blue', 'green', 'purple', 'yellow'],
        ticker: 0,
        
        init() {
          this.loadTimers();
          this.startTimerUpdates();
          
          // Force UI updates every 500ms when timers are running
          setInterval(() => {
            if (this.timers.some(t => t.isRunning)) {
              this.ticker++;
            }
          }, 500);
          
          // Handle page visibility changes
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
              this.updateTimersOnResume();
            }
          });
        },
        
        loadTimers() {
          const savedTimers = localStorage.getItem('timers');
          
          if (savedTimers) {
            try {
              this.timers = JSON.parse(savedTimers);
              this.updateTimersOnResume();
            } catch (e) {
              console.error("Error loading timers:", e);
              this.timers = [];
            }
          }
          
          // Add a default timer if none exists
          if (!this.timers.length) {
            this.addTimer();
          }
        },
        
        updateTimersOnResume() {
          const now = Date.now();
          
          this.timers.forEach(timer => {
            if (timer.isRunning && timer.lastUpdated) {
              // Calculate elapsed time while page was closed
              const timePassed = now - timer.lastUpdated;
              
              if (timer.mode === 'countdown') {
                // For countdown, check if timer should have completed
                const durationMs = timer.duration * 60 * 1000;
                timer.elapsed += timePassed;
                
                if (timer.elapsed >= durationMs) {
                  timer.elapsed = durationMs;
                  timer.isRunning = false;
                  timer.lastUpdated = null;
                  // Play notification sound on resume if timer finished
                  this.playNotification();
                } else {
                  timer.lastUpdated = now;
                }
              } else {
                // For stopwatch, just add the elapsed time
                timer.elapsed += timePassed;
                timer.lastUpdated = now;
              }
            }
          });
          
          this.saveTimers();
        },
        
        saveTimers() {
          localStorage.setItem('timers', JSON.stringify(this.timers));
        },
        
        addTimer() {
          const now = Date.now();
          const newTimer = {
            id: now.toString(),
            name: '',
            mode: 'stopwatch', // Changed from 'countdown' to 'stopwatch'
            duration: 25,
            color: this.colors[Math.floor(Math.random() * this.colors.length)],
            isRunning: true,  // Auto-start the timer
            elapsed: 0,
            lastUpdated: now  // Set the lastUpdated to now for auto-start
          };
          
          this.timers.push(newTimer);
          this.saveTimers();
        },
        
        removeTimer(index) {
          this.timers.splice(index, 1);
          this.saveTimers();
        },
        
        toggleMode(timer) {
          timer.mode = timer.mode === 'countdown' ? 'stopwatch' : 'countdown';
          timer.isRunning = false;
          timer.elapsed = 0;
          timer.lastUpdated = null;
          this.saveTimers();
        },
        
        toggleTimer(timer) {
          const now = Date.now();
          
          if (timer.isRunning) {
            // Pause
            if (timer.lastUpdated) {
              timer.elapsed += (now - timer.lastUpdated);
            }
            timer.isRunning = false;
            timer.lastUpdated = null;
          } else {
            // Start
            timer.isRunning = true;
            timer.lastUpdated = now;
          }
          
          this.saveTimers();
        },
        
        resetTimer(timer) {
          timer.isRunning = false;
          timer.elapsed = 0;
          timer.lastUpdated = null;
          this.saveTimers();
        },
        
        updateDuration(timer) {
          // Ensure duration is at least 1 minute
          if (timer.duration < 1) timer.duration = 1;
          timer.elapsed = 0;
          this.saveTimers();
        },
        
        startTimerUpdates() {
          // Update timers every second
          setInterval(() => {
            const now = Date.now();
            let needsSave = false;
            
            this.timers.forEach(timer => {
              if (timer.isRunning) {
                if (timer.mode === 'countdown') {
                  const durationMs = timer.duration * 60 * 1000;
                  const totalElapsed = timer.elapsed + (now - timer.lastUpdated);
                  
                  if (totalElapsed >= durationMs) {
                    // Timer complete
                    timer.elapsed = durationMs;
                    timer.isRunning = false;
                    timer.lastUpdated = null;
                    this.playNotification();
                    needsSave = true;
                  }
                }
              }
            });
            
            if (needsSave) {
              this.saveTimers();
            }
          }, 1000);
        },
        
        formatTime(timer) {
          // Access the ticker to ensure this function gets re-evaluated
          // when the ticker changes
          this.ticker;
          
          let timeMs;
          
          if (timer.isRunning) {
            const elapsed = timer.elapsed + (Date.now() - timer.lastUpdated);
            
            if (timer.mode === 'countdown') {
              const durationMs = timer.duration * 60 * 1000;
              timeMs = Math.max(0, durationMs - elapsed);
            } else {
              timeMs = elapsed;
            }
          } else {
            if (timer.mode === 'countdown') {
              const durationMs = timer.duration * 60 * 1000;
              timeMs = Math.max(0, durationMs - timer.elapsed);
            } else {
              timeMs = timer.elapsed;
            }
          }
          
          // Format the time as HH:MM:SS
          const totalSeconds = Math.floor(timeMs / 1000);
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;
          
          return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        },
        
        playNotification() {
          try {
            // Replace with an actual audio file later
            const audio = new Audio('notification-sound.mp3');
            audio.play();
          } catch (e) {
            console.error("Could not play notification sound:", e);
          }
        },
        
        getColorClass(color, type) {
          const colorMap = {
            'pink': {
              'bg': 'bg-pink-100',
              'button': 'bg-white/40 hover:bg-white/60 text-pink-800'
            },
            'blue': {
              'bg': 'bg-blue-100',
              'button': 'bg-white/40 hover:bg-white/60 text-blue-800'
            },
            'green': {
              'bg': 'bg-green-100', 
              'button': 'bg-white/40 hover:bg-white/60 text-green-800'
            },
            'purple': {
              'bg': 'bg-purple-100',
              'button': 'bg-white/40 hover:bg-white/60 text-purple-800'
            },
            'yellow': {
              'bg': 'bg-yellow-100',
              'button': 'bg-white/40 hover:bg-white/60 text-yellow-800'
            }
          };
          
          return colorMap[color]?.[type] || 'bg-slate-100';
        }
      };
    }
  </script>
</body>
</html>